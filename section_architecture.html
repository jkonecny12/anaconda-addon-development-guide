<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title xmlns:d="http://docbook.org/ns/docbook">2. Architecture</title><link rel="stylesheet" type="text/css" href="Common_Content/css/default.css" /><link rel="stylesheet" media="print" href="Common_Content/css/print.css" type="text/css" /><meta xmlns:d="http://docbook.org/ns/docbook" name="generator" content="publican v4.2.6" /><meta xmlns:d="http://docbook.org/ns/docbook" name="package" content="Fedora-Anaconda_Addon_Development_Guide-21-en-US-1-0" /><link rel="home" href="index.html" title="Anaconda Addon Development Guide" /><link rel="up" href="index.html" title="Anaconda Addon Development Guide" /><link rel="prev" href="index.html" title="Anaconda Addon Development Guide" /><link rel="next" href="section_hub_and_spoke.html" title="3. Hub&amp;Spoke model" /></head><body class="draft "><p id="title"><a class="left" href="http://www.fedoraproject.org"><img alt="Product Site" src="Common_Content/images//image_left.png" /></a><a class="right" href="http://docs.fedoraproject.org"><img alt="Documentation Site" src="Common_Content/images//image_right.png" /></a></p><ul class="docnav top"><li class="previous"><a accesskey="p" href="index.html"><strong>Prev</strong></a></li><li class="home">Anaconda Addon Development Guide</li><li class="next"><a accesskey="n" href="section_hub_and_spoke.html"><strong>Next</strong></a></li></ul><div class="section"><div class="titlepage"><div><div keep-together.within-column="always"><h2 class="title"><a id="section_architecture">
      ⁠</a>2. Architecture</h2></div></div></div><div class="para">
			As already noted, the Anaconda installer is a set of python modules and scripts. It also uses a number of external packages and libraries, some of which were originally created specifically for the installer. Major components of the toolset include the following packages: <span class="package">pykickstart</span>, <a id="idx_pykickstart" class="indexterm"></a> <span class="package">yum</span>, <a id="idx_yum" class="indexterm"></a> <span class="package">blivet</span> <a id="idx_blivet" class="indexterm"></a> and <span class="package">pyanaconda</span>. <a id="idx_pyanaconda" class="indexterm"></a> <span class="package">pykickstart</span> is a package that parses and validates a provided kickstart file and also provides a data structure that Anaconda uses to store values driving installation. We will focus more on the data representation and life cycle in the following paragraph. <span class="package">yum</span> is the core python package of the <code class="command">yum</code> package manager. Anaconda uses it to interface with package repositories and handle operations related to package management during installation. <span class="package">blivet</span> is a relatively recent project which was split out from the <span class="package">pyanaconda</span> package as <span class="package">pyanaconda.storage</span>. As the old name suggests, blivet is a storage library which handles all activities related to disk management. Additionally, it provides functions for boot loader installation and configuration. The <span class="package">pyanaconda</span> package acts as a glue for holding all of the components together; it contains all of the UI code and several modules for functionality unique to anaconda, such as keyboard and timezone selection, network configuration, and user creation, as well as a number of utilities and system-oriented functions. There is also the <span class="package"> python-meh </span> <a id="idx_meh" class="indexterm"></a> package which contains an exception handler that gathers and stores additional information from the system in case of a crash and passes this data to the <span class="package">libreport</span> <a id="idx_libreport" class="indexterm"></a> library, which is a part of the <a href="https://fedorahosted.org/abrt/">ABRT project</a>. <a id="idx_abrt" class="indexterm"></a>
		</div><div class="para">
			The life cycle of the data in the installation process is simple and straightforward. If a kickstart file is provided, it is parsed and processed by the <span class="package">pykickstart</span> module to behave as an in-memory, tree-like structure. If no kickstart file is given, an empty tree-like structure is created. Items in this structure are then updated with the user's choices as they are made within the UI. Next, the installation process begins, and it is driven by the values which are stored in the tree-like structure. At this point, the values are also written out as a kickstart file which can be used to perform another installation with the same configuration. Elements of the structure are defined in the <span class="package">pykickstart</span> package, but some of them are overridden by modified versions from the <span class="package">pyanaconda.kickstart</span> module. The important rule which governs this behavior is that there is nowhere to store configuration data, and the installation process is data-driven and relies on transactions as much as possible. This neatly enforces some nice features:
		</div><div xmlns:d="http://docbook.org/ns/docbook" class="itemizedlist"><ul><li class="listitem"><div class="para">
					everything has to be supported in kickstart first, because in an automated installation only the transaction happens
				</div></li><li class="listitem"><div class="para">
					there is a single and obvious point where the underlying machine starts to be modified -- this marks the beginning of the transaction
				</div></li><li class="listitem"><div class="para">
					everything configured in the UI is reflected in the resultant kickstart file
				</div></li></ul></div><div class="para">
			What does it mean that the installation is data-driven? The installation and configuration logic lies within the methods of the items in the tree-like structure. Every item is set up (the <code class="methodname">setup</code> method) <a id="idx_setup" class="indexterm"></a> to modify the runtime environment of the installation if needed, and then executed (the <code class="methodname">execute</code>) <a id="idx_execute" class="indexterm"></a> to perform the changes on the newly installed system. We will look at these methods closer in <a class="xref" href="section_writing_addon.html">Section 6, “Writing an Anaconda addon”</a>.
		</div></div><ul class="docnav"><li class="previous"><a accesskey="p" href="index.html"><strong>Prev</strong>Anaconda Addon Development Guide</a></li><li class="up"><a accesskey="u" href="#"><strong>Up</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>Home</strong></a></li><li class="next"><a accesskey="n" href="section_hub_and_spoke.html"><strong>Next</strong>3. Hub&amp;Spoke model</a></li></ul></body></html>