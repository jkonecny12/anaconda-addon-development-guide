<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title xmlns:d="http://docbook.org/ns/docbook">4. Threads and communication</title><link rel="stylesheet" type="text/css" href="Common_Content/css/default.css" /><link rel="stylesheet" media="print" href="Common_Content/css/print.css" type="text/css" /><meta xmlns:d="http://docbook.org/ns/docbook" name="generator" content="publican v4.2.6" /><meta xmlns:d="http://docbook.org/ns/docbook" name="package" content="Fedora-Anaconda_Addon_Development_Guide-21-en-US-1-0" /><link rel="home" href="index.html" title="Anaconda Addon Development Guide" /><link rel="up" href="index.html" title="Anaconda Addon Development Guide" /><link rel="prev" href="section_hub_and_spoke.html" title="3. Hub&amp;Spoke model" /><link rel="next" href="section_addon_structure.html" title="5. Addon structure" /></head><body class="draft "><p id="title"><a class="left" href="http://www.fedoraproject.org"><img alt="Product Site" src="Common_Content/images//image_left.png" /></a><a class="right" href="http://docs.fedoraproject.org"><img alt="Documentation Site" src="Common_Content/images//image_right.png" /></a></p><ul class="docnav top"><li class="previous"><a accesskey="p" href="section_hub_and_spoke.html"><strong>Prev</strong></a></li><li class="home">Anaconda Addon Development Guide</li><li class="next"><a accesskey="n" href="section_addon_structure.html"><strong>Next</strong></a></li></ul><div class="section"><div class="titlepage"><div><div keep-together.within-column="always"><h2 class="title"><a id="section_threads_and_communication">
      ⁠</a>4. Threads and communication</h2></div></div></div><div class="para">
			Some of the actions that need to be run during the installation process take a long time to be finished (e.g. scanning disks for existing partitions, downloading package repository metadata, etc). And since basic principle of the GUI programming is that the user interface should be as responsive as possible and since the goal is to allow user configure other settings while some are blocked by the long lasting actions, the Anaconda installer has to run such actions in separate threads. However, the Gtk toolkit doesn't support changing its elements from multiple threads. The Gtk main event loop is running in the main thread of the Anaconda installer process and every code doing some GUI involving actions has to make sure that these actions are run in the main thread as well. The only supported way to do that is by using <code class="methodname">GLib.idle_add</code> method which is not much comfortable. To facilitate this issue there are some helper functions and decorators  defined in the <span class="package"> pyanaconda.ui.gui.utils </span> module. The most useful ones are <span class="emphasis"><em> @gtk_action_wait </em></span> and <span class="emphasis"><em> @gtk_action_nowait </em></span> decorators that change the decorated function or method in a way that when it is called it is automatically queued to Gtk's main loop, run in the main thread and then the return value is returned to the caller or dropped, respectively.
		</div><div class="para">
			As it has been already mentioned one of the goals of using multiple threads is to allow user configure something else while some parts of the GUI wait for some actions to finish. The example of such case is package repository metadata download which can take a while and without it being finished the Source <a id="idx_source_spoke" class="indexterm"></a> and Software <a id="idx_softw_spoke" class="indexterm"></a> spokes cannot be visited as they cannot display valid data. But in the same time there is no reason why e.g. the Datetime spoke <a id="idx_datetime_spoke" class="indexterm"></a> should be blocked. Now let's take a look from the blocked spoke's perspective. It waits for some background thread to finish. But once this thread is finished how should the spoke announce it is ready and should not be blocked anymore? The hub that provides an access to the spoke has no relation with the thread the spoke has been waiting for and thus can't tell whether the spoke is yet ready or not. For such cases there is a message queue called <span class="emphasis"><em>hubQ</em></span> <a id="idx_hubq" class="indexterm"></a> that is being periodically checked in the main event loop. Once the thread the spoke has been waiting for is finished the spoke sends a message <a id="idm242233283536">
      ⁠</a><a xmlns:d="http://docbook.org/ns/docbook" href="#ftn.idm242233283536" class="footnote"><sup class="footnote">[3]</sup></a> that announces the spoke should no longer be blocked. The same applies to the situation when the spoke needs to refresh its status or completion flag. In case of the Progress hub there is the <span class="emphasis"><em> progressQ </em></span> <a id="idx_progressq" class="indexterm"></a> which serves as a medium to transfer installation progress updates. These mechanisms are needed also for the text mode where the situation is much more complicated, because there is no main loop in the text mode and for vast majority of time it is waiting for an input from keyboard. However there is (a bit experimental) implementation of asynchronous messages handling in TUI and the goal is to make, from spoke's perspective, everything very similar to the graphical user interface.
		</div><div class="footnotes"><br /><hr /><div id="ftn.idm242233283536" class="footnote"><div class="para"><a href="#idm242233283536" class="para"><sup class="para">[3] </sup></a>
				internally it means that it puts a message to the queue
			</div></div></div></div><ul class="docnav"><li class="previous"><a accesskey="p" href="section_hub_and_spoke.html"><strong>Prev</strong>3. Hub&amp;Spoke model</a></li><li class="up"><a accesskey="u" href="#"><strong>Up</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>Home</strong></a></li><li class="next"><a accesskey="n" href="section_addon_structure.html"><strong>Next</strong>5. Addon structure</a></li></ul></body></html>